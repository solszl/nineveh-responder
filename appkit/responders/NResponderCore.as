/** * NResponderCore class *  * @since 8/24/2010: 1.1 - Added responder.target !== toTarget to prevent global dispatchs to different targets. *  * @version NResponderCore v1.1 * @author Diney Bomfim */package appkit.responders {	import flash.events.Event;	import flash.utils.Dictionary;		/**	 * The core processor for NResponders	 * 	 * @langversion ActionScript 3.0	 * @playerversion Flash 9.0	 */	internal final class NResponderCore	{			//**************************************************	//  Constants	//**************************************************							//**************************************************	//  Public Properties	//**************************************************				/**		 * Use to immediately stop the dispatches in the NResponder Chain.		 * Just take effect if it is set during the dispatch process.		 * 		 * @see	NResponder#stopPropagate()		 */		public var stopPropagate:Boolean;			//**************************************************	//  Protected / Private Properties	//**************************************************				/**		 * The NResponder List.		 */		private var $responders:Array = new Array();				/**		 * The NResponder Chain List.		 */		private var $chains:Dictionary = new Dictionary(true);				/**		 * The NResponder Targets List.		 */		private var $targets:Dictionary = new Dictionary(true);				/**		 * The NResponder Listeners List.		 */		private var $listeners:Dictionary = new Dictionary(true);				/**		 * The reference count system to manage the native events.		 */		private var $referenceCount:Dictionary = new Dictionary(true);				/**		 * The Array of indexes with current NResponder in execution.		 * Need to be an Array to prevent conflicts with recursively dispatches.		 */		private var $currents:Array = new Array();			//**************************************************	//  Initialization	//**************************************************							//**********************************************************************************************************	//	//  Public Methods	//	//**********************************************************************************************************				/**		 * Register a new NResponder instance.		 * 		 * @param	responder		The NResponder instance to register.		 * 		 * @see	NResponder#add()		 * 		 * @see	NResponder#addNative()		 */		public function register(responder:NResponder):void		{			var index:int = searchHash(responder.hash, responder.listener);						var chain:Array = $chains[responder.action] ||= new Array();			var target:Array = $targets[responder.target] ||= new Array();			var listener:Array = $listeners[responder.listener] ||= new Array();						// New instance of a NResponder to be add.			if (index === -1)			{				// Go to last position.				index = $responders.length;								// Set indexable keyValues.				if (chain.indexOf(index) === -1)				{					chain[chain.length] = index;				}								if (target.indexOf(index) === -1)				{					target[target.length] = index;				}								if (listener.indexOf(index) === -1)				{					listener[listener.length] = index;				}								// Register native event if needed.				if (responder.isNative)				{					// Register the native callback function.					responder.target.addEventListener(responder.action, receiveNative, false, -responder.order, true);										// Alloc a new reference count to this target if it has no one.					$referenceCount[responder.hash] ||= 0;										// Retain one reference count.					$referenceCount[responder.hash] += 1;				}			}						$responders[index] = responder;		}				/**		 * Remove a NResponder or NResponder Action from NResponder Chain.		 * 		 * @param	action			A NResponder Action.		 * 		 * @param	listener		A registered listener.		 * 		 * @param	toTarget		A registered target.		 * 		 * @return					True indicate the one or more NResponders was removed. False indicates that		 * no NResponder was removed.		 * 		 * @see	NResponder#remove()		 */		public function remove(action:String, listener:Function, toTarget:Object):Boolean		{			var removeArray:Array = filter(action, listener, toTarget);			var index:int = NaN;						for each(index in removeArray)			{				excludeFrom(index);			}						return !isNaN(index);		}				/**		 * Check if an action and/or listener is in NResponder Chain.		 * 		 * @param	action			A NResponder Action.		 * 		 * @param	listener		A registered listener.		 * 		 * @param	toTarget		A registered target.		 * 		 * @return					True indicate the one or more NResponders deal with the informed parameters.		 * False indicates that no NResponder was founded to informed parameters.		 * 		 * @see	NResponder#has()		 */		public function has(action:String, listener:Function, toTarget:Object):Boolean		{			// Check all indexable keys to find this combination.			return filter(action, listener, toTarget) !== null;		}				/**		 * Dispatch a NResponder Action.		 * 		 * @param	action			A NResponder Action.		 * 		 * @param	params			An Array of parameters to pass to each listener.		 * 		 * @param	toTarget		A registered target.		 * 		 * @see	NResponder#dispatch()		 */		public function dispatch(action:String, params:Array, toTarget:Object):void		{			var chain:Array = (toTarget === null) ? $chains[action] : filter(action, null, toTarget);			var responder:NResponder;			var current:int = $currents.length;			var index:int;						// Clear any call of stopPropagate() outside the dispatch process.			stopPropagate = false;						// Make the ordanation.			chain = reorder(chain);						for each(index in chain)			{				responder = $responders[index];								// Set the current NResponder`s index.				$currents[current] = responder;								// First check if NResponder and current dispatch has the same targets.				// After try to perform the NResponder respecting it's delay.				// If don't match the targets or is in delay time, continue the loop.				if (responder.target !== toTarget || !responder.perform(params, true))				{					continue;				}								// Decrease multiple replies of NResponder				// and remove it if necessary.				if (responder.replies > 1)				{					--responder.replies;				}				else if (responder.replies === 1)				{					excludeFrom(index);				}								// Immediately stop the propagation of current action.				if (stopPropagate)				{					break;				}			}						// Clear the current NResponder to prevent access out of this execution.			$currents.splice(current, 1);		}			//**********************************************************************************************************	//	//  Protected / Private Methods	//	//**********************************************************************************************************				/**		 * Search for a specific NResponderHash.		 * 		 * @param	hash			The Hash to search.		 * 		 * @param	withListener	The listener to compare.		 * 		 * @return					Return the index of matched NResponderHash.		 */		private function searchHash(hash:uint, withListener:Function):int		{			var index:int = -1;			var responder:NResponder;						for each(responder in $responders)			{				++index;								// Check the hash and listener of the valid NResponders.				if (responder !== null && responder.hash === hash && responder.listener === withListener)				{					return index;				}			}						return -1;		}				/**		 * Reorder an Array of NResponder Indexes based on NResponder Orders.		 * 		 * @param	listToSort		The list (Array) of indexes.		 * 		 * @return					The ordered list (Array).		 */		private function reorder(listToSort:Array):Array 		{			if (listToSort !== null)			{				var minimum:int;				var iSearch:int;				var iMinimum:int;				var iToSort:int;				var replacedValue:int;				var length:int = listToSort.length;								// Start to search in Array.				for (iSearch = 0; iSearch < length; ++iSearch)				{					// Prepare changes to the first element.					replacedValue = listToSort[iSearch];					minimum = ($responders[replacedValue] as NResponder).order;					iToSort = iSearch;										// Search in subsequent elements to compare the orders.					for (iMinimum = iSearch + 1; iMinimum < length; ++iMinimum)					{						// When find the minimum order, prepare it to change it's position.						if (($responders[listToSort[iMinimum]] as NResponder).order < minimum)						{							replacedValue = listToSort[iMinimum];							minimum = ($responders[replacedValue] as NResponder).order;							iToSort = iMinimum;						}					}										// Swap the positions of the current search index and the next minimum index.					listToSort[iToSort] = listToSort[iSearch];					listToSort[iSearch] = replacedValue;				}			}						return listToSort;		}				/**		 * Return an Array contain the filtered result.		 * This filter cross the indexes based in an Action, a Listener and a Target. The index must exist		 * in all set parameter to be valid.		 * If a parameter is set to null, this represent that filter will not consider the null parameter.		 * 		 * <p/>		 * 		 * If all parameter is null, this will return all indexes in the NResponder Chain.		 * 		 * @param	action		An action to filter.		 * 		 * @param	listener	A listener to filter.		 * 		 * @param	toTarget	A target to filter.		 * 		 * @return				The filtered Array.		 */		private function filter(action:String, listener:Function, toTarget:Object):Array 		{			var returnArray:Array;			var checkArray:Array;			var index:int;						// Check Actions List.			if (action !== null)			{				returnArray = [];								for each(index in $chains[action]) 				{					returnArray[returnArray.length] = index;				}			}						// Check Listeners List.			if (listener !== null)			{				// Fast Add.				if (returnArray === null)				{					returnArray = [];										for each(index in $listeners[listener]) 					{						returnArray[returnArray.length] = index;					}				}				// Filter.				else				{					checkArray = [];										for each(index in $listeners[listener]) 					{						if (returnArray.indexOf(index) !== -1)						{							checkArray[checkArray.length] = index;						}					}										returnArray = checkArray;				}			}						// Check Targets List.			if (toTarget !== null)			{				// Fast Add.				if (returnArray === null)				{					returnArray = [];										for each(index in $targets[toTarget]) 					{						returnArray[returnArray.length] = index;					}				}				// Filter.				else				{					checkArray = [];										for each(index in $targets[toTarget]) 					{						if (returnArray.indexOf(index) !== -1)						{							checkArray[checkArray.length] = index;						}					}										returnArray = checkArray;				}			}						// At this point, returnArray can be null or []. If it is [], null it.			if (returnArray !== null && returnArray.length === 0)			{				returnArray = null;			}						return returnArray;		}				/**		 * Exclude a NResponder based on a listener and a target.		 * 		 * @param	index		The index of the NResponder to be removed.		 */		private function excludeFrom(index:int):void		{			// Prevents excludes during a callBack that exclude own NResponder.			if ($responders[index] === null)			{				return;			}						var responder:NResponder = $responders[index];			var chain:Array = $chains[responder.action];			var target:Array = $targets[responder.target];			var listener:Array = $listeners[responder.listener];						// Clear native events.			if (responder.isNative)			{				// Release the one retain for this target.				$referenceCount[responder.hash] -= 1;								// If this target has nor references, dealloc it.				if ($referenceCount[responder.hash] === 0)				{					delete $referenceCount[responder.hash];					responder.target.removeEventListener(responder.action, receiveNative);				}			}						// Remove NResponder.			$responders[index] = null;						// Remove index lists.			chain.splice(chain.indexOf(index), 1);			target.splice(target.indexOf(index), 1);			listener.splice(listener.indexOf(index), 1);						// Clear index lists if needed.			if (chain.length === 0)			{				delete $chains[responder.action];			}						if (target.length === 0)			{				delete $targets[responder.target];			}						if (listener.length === 0)			{				delete $listeners[responder.listener];			}		}				/**		 * Receive the native event and dispatch the corresponding NResponder Action.		 * 		 * @param	event		Any kind of event or pseudo-event that native dispatch.		 */		private function receiveNative(event:Event):void		{			// Dispatch the native following the NResponder's rules.			dispatch(event.type, [event], event.currentTarget);		}			//**********************************************************************************************************	//	//  Getters / Setters	//	//**********************************************************************************************************				/**		 * Return the Object associated with current called NResponder of a NResponder Action.		 * 		 * <p/>		 * 		 * This method just return an Object if the called NResponder are in execution and if an Object was		 * previously associated with it. Otherwise, will return <code>null</code>.		 */		public function get currentTarget():Object { return currentNResponder.target; }				/**		 * Return the Action that as under execution in this moment.		 * 		 * <p/>		 * 		 * This method just return an Action if some Action is in execution.		 * Otherwise, will return <code>null</code>.		 */		public function get currentAction():String { return currentNResponder.action; }				/**		 * Return the Action that as under execution in this moment.		 * 		 * <p/>		 * 		 * This method just return an Action if some Action is in execution.		 * Otherwise, will return <code>null</code>.		 */		public function get currentNResponder():NResponder { return $currents[$currents.length - 1]; }			}}